#pragma once
// P-8

P* MUL_PP_P(P* First, P* Second)
{
	short i; // Для перебора коэффициентов многочлена
	P* Result = initP(); // Результат умножения
	P* Temp = initP(); // Результат умножения первого многочлена на коэффициент второго
	Result->len = (First->len) + (Second->len); // Степень результата равна сумме степеней множителей
	Result->k = (Q**)malloc((Result->len) * sizeof(Q*)); // Освобождаем память под результат
													  // Заполнение всех коэф-ов нулями
	for (i = First->len; i <= 0; i--)
	{
		Temp = MUL_PQ_P(Second, First->k[i]); // Умножаем второй многочлена поочередно на все коэффициенты первого
		Temp = MUL_Pxk_P(Temp, i); // Умножаем произведение на текущую исследуемую степень первого многочлена
		Result = ADD_PP_P(Result, Temp); // Прибавление к результату произведения
	}
	return Result;
}