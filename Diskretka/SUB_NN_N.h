#pragma once
// N-5 Марушевский Тихон

N* SUB_NN_N(N* a, N* b)
{
	N* c = zeroN();
	int l = 0; // степень результата
	if (COM_NN_D(a, b) == 2) { // проверка на правильность введенных данных
		for (int i = 0; i < a->len; i++) // цикл до конца числа
		{
			c->n = (int*)realloc(c->n, (l + 1) * sizeof(int));// выделение памяти под очередную цифру результата
			if (i < b->len) // если счётчик меньше длины меньшего числа (числа "накладываются" друг на друга)
			{
				if (a->n[i] >= b->n[i]) // если цифра большего числа больше или равна цифре меньшего числа
					c->n[i] = a->n[i] - b->n[i]; // проводим обыкновенное вычитание
				else if (a->n[i] < b->n[i]) // если цифра большего числа меньше цифры меньшего числа
				{
					c->n[i] = a->n[i] + 10 - b->n[i]; // мы "занимаем" десятку у более старшего разряда и проводим вычитание
					int g = i; // копируем показание счётчика
					bool flag = false; // инициализируем флаг как опущенный
					do
					{
						a->n[g] += 9; // прибавлем ко всем разрядам выше текущего девятку
						g++; // увеличиваем счётчик (поднимаемся на цифру выше) на 1
						flag = true; // поднимаем флаг
					} while (a->n[g] == 0); // до тех пор, пока не наёдется ненулевая цифра
					if (flag) // весли флаг поднят
						a->n[g]--; // отнимаем от цифры "заёмщика" единицу
				}
			}
			else
				c->n[i] = a->n[i]; // иначе мы ничего с цифрами не делаем, а просто "переписываем" их в результат
			l++; // увеличиваем счётчик степени результата на 1
		}
		for (int i = l - 1; i >= 0 && c->n[i] == 0; i--) // до тех пор пока не найдется ненулевое число (отбрасываем образовавшиеся незначащие нули)
		{
			c->n = (int*)realloc(c->n, (l - 1) * sizeof(int)); // сокращаем память для результата
			l--; // уменьшаем показатель степени результата
		}
		c->len = l; // присваиваем длине результата показатель счётчика
	}
	return c;
}