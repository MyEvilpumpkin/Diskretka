#pragma once
// N-4

N* ADD_NN_N(N* a, N* b)
{
	N* result;
	if (COM_NN_D(a, b) == 2) //Если a>b
	{
		result = assignmentN(a); //Будем прибавлять к а
		int size = b->len; //Если у b меньше разрядов чем у а, то нет нужды изменять разряды, начиная с b->len+2
		for (int i = 0; i < size; i++)
		{
			result->n[i] += b->n[i];	//Складываем соответствующие разряды
			if (result->n[i]>9)		//Если результат больше 9, то берём остаток от деления на 10 и добавляем единицу в следующий разряд
			{
				result->n[i] %= 10;
				int g = i;
				do {
					if (g == result->len - 1)	//Если следующего разряда нет, то он создаётся
					{
						result->n = (int*)realloc(result->n, (++result->len) * sizeof(int));
						result->n[g + 1] = 1;	//Следующему "пустому" разряду присваивается единица
					}
					else
						result->n[g + 1]++; //В случае если следующий разряд существует, он увеличивается на единицу
					result->n[g + 1] %= 10;
					g++;
				}
				while (result->n[g]%10 == 0);
			}
		}
	}
	else //Если a<b
	{
		result = assignmentN(b);	//Будем прибавлять к b
		int size = a->len; //Если у а меньше разрядов чем у b, то нет нужды изменять разряды, начиная с a->len+2
		for (int i = 0; i < size; i++)
		{
			result->n[i] += a->n[i];	//Складываем соответствующие разряды
			if (result->n[i]>9)		//Если результат больше 9, то берём остаток от деления на 10 и добавляем единицу в следующий разряд
			{
				result->n[i] %= 10;
				int g = i;
				do {
					if (g == result->len - 1)	//Если следующего разряда нет, то он создаётся
					{
						result->n = (int*)realloc(result->n, (++result->len) * sizeof(int));
						result->n[g + 1] = 1;	//Следующему "пустому" разряду присваивается единица
					}
					else
						result->n[g + 1]++; //В случае если следующий разряд существует, он увеличивается на единицу
					result->n[g + 1] %= 10;
					g++;
				} while (result->n[g] % 10 == 0);//В случае если следующий разряд существует, он увеличивается на единицу
			}
		}
	}
	return result;
}