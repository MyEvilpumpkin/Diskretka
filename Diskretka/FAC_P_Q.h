#pragma once
// P-7

Q* FAC_P_Q(P* Polyn)
{
	N* NOD = ABS_Z_N(Polyn->k[Polyn->len]->num); // НОД числителей, изначально присваиваем значение, равное числителю старшего коэффициента многочлена
	N* Module; // Временная переменная - модуль числителя коэффициента
	N* NOK = Polyn->k[Polyn->len]->denom; // НОК знаменателей, изначально присваиваем значение, равное знаменателю старшего коэффициента многочлена
	Q* Result = initQ(); // Числитель дроби - НОД числителей, знаменатель - НОК знаменателей
	short i, // Для перебора коэффициентов многочлена
		Flag; // Для корректной работы цикла 
	for (i = (Polyn->len) - 1; i >= 0; i--) // Перебираем все коэффициенты многочлена, начиная с "предстаршего" (т.к. старший занес в НОК изначально)
		NOK = LCM_NN_N(NOK, Polyn->k[i]->denom); // Находим поочередно НОК общего НОК и данного коэффициента		 
	for (i = (Polyn->len) - 1; i >= 0; i--) // Перебираем все коэффициенты многочлена, начиная с "предстаршего" (т.к. старший занес в НОД изначально)
	{
		Flag = POZ_Z_D(Polyn->k[i]->num); // Проверка коэффициента на нуль
		if (Flag != 0)
		{
			Module = ABS_Z_N(Polyn->k[i]->num); // Переводим числитель коэффициента в натуральное
			NOD = GCF_NN_N(NOD, Module); // Находим поочередно НОД общего НОД и данного коэффициента
		}
	}
	Result->num->number = assignmentN(NOD); // Присваиваем Result->num значение NOD
	Result->num->sign = true;
	Result->denom = assignmentN(NOK); // Присваиваем Result->denom значение НОК
	// Ниже преобразование многочлена
	for (i = Polyn->len; i >= 0; i--) // Перебираем все коэффициенты многочлена
		Polyn->k[i] = DIV_QQ_Q(Polyn->k[i], Result); // Делим каждый коэффициент на полученную дробь
	return Result;
}